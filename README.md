# xcffib [![Build Status](https://travis-ci.org/tych0/xcffib.svg?branch=master)](https://travis-ci.org/tych0/xcffib)

`xcffib` is intended to be a (mostly) drop-in replacement for `xpyb`. `xpyb`
has an inactive upstream, several memory leaks, is python2 only and doesn't
have pypy support. `xcffib` is a binding which uses
[cffi](https://cffi.readthedocs.org/), which mitigates some of the issues
described above. `xcffib` also builds bindings for 27 of the 29 (xprint and xkb
are missing) X extensions in 1.10.

## Dependencies

Currently `xcb-types` (any tagged version, not just the old one on Hackage)
doesn't run against `xcb-proto` 1.10; there is a hacked branch available at
[tych0/xcb-types](http://github.com/tych0/xcb-types) that allows you to parse
xcb-proto 1.10 mostly correctly. Other than that, you should be able to install
all the deps from hackage or pip. The
[.travis.yaml](https://github.com/tych0/xcffib/blob/master/.travis.yml) has an
example of how to install the dependencies on Ubuntu flavors.

## Differences

There are lots of differences right now between `xpyb` and `xcffib`, mostly
because `xcffib` isn't done yet :-)

* In general, you should `s/xcb/xcffib/g`
* `xcb.Exception` is spelled `xcffib.XcffibException` and is also a parent of
   all exceptions generated by xcffib.
* `xcb.ConnectException` is gone, it was unused
* `xcffib.ConnectionException` is raised on connection errors
* The `FooError` `BadFoo` duality is gone; it was difficult to understand what
  to actually catch if you wanted to handle an error. Instead, only `FooError`
  remains, which implements both the X error object description and python
  Exception (via inheriting from `xcffib.XcffibException`).
* `xcb.Iterator` is gone; similar functionality is implemented by
  `xcffib.pack_list`.
* `xcb.Request` is gone. It was an entirely internal and unnecessary interface.

## Enhancements

* When sending requests with nested structs you no longer have to pack the
  contents yourself. For example, when calling `xproto.FillPoly`, you used to
  have to convert the `POINT`s you were passing in to some sort of buffer which
  had them `struct.pack`'d. Now, you can just pass an iterable (or
  `xcffib.List`) of `POINT`s and it will be automatically packed for you.
* Most of the lower level XCB connection primitives that were previously not
  exposed are now available via `xcffib.ffi.{ffi,C}`, assuming you want to go
  out of band of the binding.

## Why haskell?

Why is the binding generator written in haskell? Because haskell is awesome.

## TODO

* XGE support? (xpyb doesn't implement this either)
* xprint and xkb support. These will require some non-trivial work in
  xcb-types, since it won't parse them correctly.
